$Debug=0  # 1 : debug mode: will not delete any log. include eventlog
          # 0 : Normal mode: will delete files

$DeleteEventLogs=1  # 1: delete,  0: no delete.  use this for testing script


# ============== Begin Config 

if(test-Path 'C:\SBCRemediation'){
    # SBC Computer
    $MD5HashApps=@('C:\SBCRemediation\DKMS.SBC.WebApp.exe')  # ## file hash and version info
    $Process=@('DKMS.SBC.WebApp')  # ## cpu ram usage
    $BackupFolders=@('C:\SBCRemediation\log','C:\SBCRemediation\PSLogs')
    #$ScreenshotApps=@('mspaint','notepad')
    #$ScreenshotApps=@()
}
else{
    
    # Kiosk Computer

    if(test-Path 'C:\DKMSClient'){
        ## KT/BT
        $MD5HashApps=@('C:\DKMSClient\DKMSKiosk.exe')  # ## file hash and version info
        $Process=@('DKMSKiosk')  # ## cpu ram usage
        $BackupFolders=@('C:\DKMSClient\log','C:\DKMSClient\transaction')
        #$ScreenshotApps=@('DKMSKiosk')
    }
    else{
        # PPT
        $MD5HashApps=@('C:\DKMSRemediation\DKMS.Kiosk.WebApp.exe')  # ## file hash and version info
        $Process=@('DKMS.Kiosk.WebApp')  # ## cpu ram usage
        $BackupFolders=@('C:\DKMSRemediation\log','C:\DKMSRemediation\transaction', 'C:\DKMSRemediation\LEDChangeStateTrace', 'C:\DKMSRemediationTMS\log')
        #$ScreenshotApps=@('DKMS.Kiosk.WebApp')
    }
}

# ============== End Config

$hostname=(Get-CimInstance -classname win32_computersystem).Name
$dt = (get-date -f yyyyMMdd)

$Ports=@('455','355','255','155')


#ppt1 155
#brani 255
#keppel 255
#ppt2 355
#mb 455

$TopRankUsage=5
$MaxLogWEntries=2 #1000

#$ArchiveFolder_Final="C:\_Maintenance\ArchivedLogs\" # Must end with a backsplash. do not move this line

$ArchiveName="ArchivedLogs_" + $hostname + "_$dt"
$ArchiveFolder_Tmp="C:\$ArchiveName\" # Must end with a backsplash
#$ZipTarget = "$ArchiveFolder_Final\$ArchiveName.zip"

$OutFile="$ArchiveFolder_Tmp$hostname.$dt.txt"
$ReportFile="$ArchiveFolder_Tmp$hostname.$dt.html"


$global:ReportSummary = [Environment]::NewLine

Function AddToSummary($str){

    if($str -eq $null){
        return
    }

    if($str -is [String]){
        $global:ReportSummary +=  $str + [Environment]::NewLine
    }
    else{
        $global:ReportSummary += (Out-String -InputObject $str -Width 200)  + [Environment]::NewLine
    }

  #write-output $str
  #write-output $ReportSummary
  #Read-host "Press enter to exit."
}

Function prn ($str){
#param(
    #[Parameter(Mandatory=$True,ValueFromPipeline=$True)]
    #[object]$str = $null
#)

    Write-Output $str

    if($str -eq $null){
        return
    }

    if($str -is [String]){
        Add-Content $OutFile $str
    }
    else{
        #$x = Out-String -InputObject $str -Width 100
        #Add-Content $OutFile $x #| Set-Content
        Add-Content $OutFile (Out-String -InputObject $str -Width 200)
    }
    
}

Function Border{
    Param
    (
         [Parameter(Mandatory=$true, Position=0)]
         [string] $str
         #,
         #[Parameter(Mandatory=$true, Position=1)]
         #[int] $len
    )
    $str += " for host $hostname"

    $tl= "╔" ; $tr= "╗" ; $bl= "╚" ; $br= "╝"
    
    $bv="║" ; $bh="═"

    $len = 60


    if ($str.length -gt $len) {
        $len= $str.length + 10 # 5 spaces left & right
    }

    $spacing = [math]::floor(($len - $str.length)/2)

    $spacing = " " * $spacing

    $pad= " " * ($len - ($spacing.length*2) - $str.Length)

    prn "$($tl)$($bh * $len)$($tr)"
    prn "$($bv)$(" " * $len)$($bv)"
    prn "$($bv)$($spacing)$($str)$($spacing)$($pad)$($bv)"
    prn "$($bv)$(" " * $len)$($bv)"
    prn "$($bl)$($bh * $len)$($br)"

}

Function GetAvailResources(){
    
    $Array = @()

    $Server=$hostname
    #prn $sep
    #prn 'Total Resource'
    #prn $sep
    Border 'System Summary'
    #prn  "Processing $Server machine"
 
    $Check = $null
    $Processor = $null
    $ComputerMemory = $null
    $RoundMemory = $null
    $Object = $null
 
    # Creating custom object
    $Object = New-Object PSCustomObject
    $Object | Add-Member -MemberType NoteProperty -Name "DKMS Client Name" -Value $hostname
 
    $Check = Test-Path -Path "\\$Server\c$" -ErrorAction SilentlyContinue
    $Check="True"

    If($Check -match "True")
    {
        $Status = "True"
 
        Try
        {
            # Processor utilization
            $Processor = (Get-WmiObject -ComputerName $Server -Class win32_processor -ErrorAction Stop | Measure-Object -Property LoadPercentage -Average | Select-Object Average).Average
  
            # Memory utilization
            $ComputerMemory = Get-WmiObject -ComputerName $Server -Class win32_operatingsystem -ErrorAction Stop
            $Memory = ((($ComputerMemory.TotalVisibleMemorySize - $ComputerMemory.FreePhysicalMemory)*100)/ $ComputerMemory.TotalVisibleMemorySize)
            $RoundMemory = [math]::Round($Memory, 2)
        }
        Catch
        {
            Write-Host "Something went wrong" -ForegroundColor Red
            Continue
        }
 
        If(!$Processor -and $RoundMemory)
        {
            #$RoundMemory = "(null)"
            #$Processor = "(null)"
        }
 
        $Object | Add-Member -MemberType NoteProperty -Name "Is online?" -Value $Status
        $Object | Add-Member -MemberType NoteProperty -Name "Total RAM" -Value  $ComputerMemory.TotalVisibleMemorySize.ToString('N2')
        $Object | Add-Member -MemberType NoteProperty -Name "Free RAM" -Value  $ComputerMemory.FreePhysicalMemory.ToString('N2')
        $Object | Add-Member -MemberType NoteProperty -Name "Memory %" -Value $RoundMemory 
        $Object | Add-Member -MemberType NoteProperty -Name "CPU %" -Value $Processor 
 
        # Display resutls for single server in realtime
        #$Object
  
        # Adding custom object to our array
        $Array += $Object
    }
    Else
    {
        $Object | Add-Member -MemberType NoteProperty -Name "Is online?" -Value "False"
        $Object | Add-Member -MemberType NoteProperty -Name "Memory %" -Value "(null)" 
        $Object | Add-Member -MemberType NoteProperty -Name "CPU %" -Value "(null)" 
         
        # Display resutls for single server in realtime
        #$Object
  
        # Adding custom object to our array
        $Array += $Object
    }
  
 
    If($Array)
    { 
        $str=$Array | Sort-Object "Is online?" | format-table
        prn  $str
        AddToSummary $str;

        #$Array | Out-GridView
        #$Array | Export-Csv -Path "C:\users\$hostname\desktop\results.csv" -NoTypeInformation -Force
    }

        #prn $sep
    #prn 'Disk Space'
    #prn $sep
    #Border 'Disk Space'
    $str = Get-WMIObject Win32_LogicalDisk -Filter "DriveType=3" -Computer . | 
                Select  SystemName, 
                    DeviceID, 
                    VolumeName, 
                    @{Name="Total Size (GB)"; Expression={"{0:N1}" -F ($_.Size/1GB)}}, 
                    @{Name="Free Space (GB)"; Expression={"{0:N1}" -F ($_.Freespace/1GB)}}, 
                    @{Name="Free Space %"; Expression={"{0:N1}" -F (($_.Freespace/$_.Size)*100)}} | FT -AutoSize

    prn  $str
    AddToSummary $str

    #Get-WmiObject -Class Win32_NTEventlogFile | Where-Object LogfileName -Match 'system'
    #Get-WmiObject -Class Win32_NTEventlogFile | Where-Object LogfileName -Match 'application'
    #Get-WmiObject -Class Win32_NTEventlogFile | Where-Object LogfileName -Match 'security'
}

Function GetProcCpuRam(){

    $properties=@(
        @{Name="Name"; Expression = {$_.name}},
        @{Name="PID"; Expression = {$_.IDProcess}},
        @{Name="CPU (%)"; Expression = {$_.PercentProcessorTime}},
        @{Name="Memory (MB)"; Expression = {[Math]::Round(($_.workingSetPrivate / 1mb),2)}}
        @{Name="Disk (MB)"; Expression = {[Math]::Round(($_.IODataOperationsPersec / 1mb),2)}}
        @{Name="Path";Expression = {(Get-Process -Id $_.IDProcess).Path}}
		
    )

    $ProcessCPU = Get-WmiObject -class Win32_PerfFormattedData_PerfProc_Process

    
    $arr= @()
    foreach ($p in $Process) {
        $obj= $ProcessCPU | Where-Object {$_.Name -eq $p} | Select-Object $properties
        $arr += $obj
    }
    #prn $sep
    #prn "Resource usage by DKMS apps"
    #prn $sep
    Border "Resource usage by DKMS apps"
    $arr  = $arr | Format-Table -AutoSize
    prn  $arr
    AddToSummary $arr

    $P =   $ProcessCPU | Where-Object {$_.Name -ne "_Total" -and $_.Name -ne "Idle"} |
        Select-Object $properties |
        Sort-Object "CPU (%)" -desc |
        Select-Object -First $TopRankUsage |
        Format-Table -AutoSize

    #prn $sep
    #prn "Resource usage sort by CPU"
    #prn $sep
    Border "Top $TopRankUsage CPU usage"
    prn $P

    $P =   $ProcessCPU | Where-Object {$_.Name -ne "_Total" -and $_.Name -ne "Idle"} |
        Select-Object $properties |
        Sort-Object "Memory (MB)" -desc |
        Select-Object -First $TopRankUsage |
        Format-Table -AutoSize

    #prn $sep
    #prn "Resource usage sort by RAM"
    #prn $sep
    Border "Top $TopRankUsage RAM usage"
    prn $P
    ##$ProcessCPU.GetType()

}

Function GetPorts(){
    
    $out=""
    foreach ($p in $Ports) {
        #prn $sep
        #Write-Host "netstat -an | findstr $p"
        #prn $sep
        Border "netstat -an | findstr $p"
        cmd.exe /c "netstat -an | findstr $p > tmp.txt"  
        #$tmp = (&"netstat.exe -an | findstr $p" PCNAME 2>&1) 
        #$tmp = (cmd.exe /c "dir > tmp.txt | type tmp.txt" 2>&1)

        foreach($line in Get-Content .\tmp.txt) {
          prn $line
          AddToSummary $line
        }
    }
}

Function GetFileInfo(){
    Border "File Info"
    foreach ($a in $MD5HashApps) {
        
        $vi = (dir $a).VersionInfo 
        $hash = Get-FileHash $a -Algorithm MD5
        ##$vi | Add-Member  Add-Member Properties  "MD5_HASH" $hash.Hash
        $vi | add-member -membertype noteproperty -name MD5_HASH -value $hash.Hash | Out-Null
        
        ##$vi | fl
        ##$hash
        ##$hash.hash
        ##$vi | gm -MemberType Properties
        $o = $vi | select -Property * | Sort-Object  -Property name –Descending

        prn "File : $a"
        prn $o
    }
}

Function GetEvents(){
#Where-Object {$_.Name -ne "_Total" -and $_.Name -ne "Idle"} |
    #$obj = Get-WinEvent
    
    return Get-WmiObject -Class Win32_NTEventLogFile | Where-Object { 
        ($_.LogFileName -eq 'system') -or 
        ($_.LogFileName -eq 'application') -or 
        ($_.LogFileName -eq 'security')
    }
}

Function BackupEventLog(){

    $EvtLogSavTmpPath = $ArchiveFolder_Tmp +"EventLogs\" # Must end with a backsplash
    #prn $EvtLogSavTmpPath

    New-Item -ItemType Directory -Force -Path $EvtLogSavTmpPath  | Out-Null

    Border "Event logs before archiving"
    $list = GetEvents 
    prn $list

    New-Item -ItemType Directory -Force -Path $EvtLogSavTmpPath  | Out-Null
    Border "Archiving event logs"
    
    foreach($l in $list){
        if($l.NumberOfRecords -gt 1){
            
            $logFileName=$l.logFileName
            $exportFileName = $logFileName + "_" + (get-date -f yyyyMMdd) + ".evt"
            prn "Archiving Event : $logFileName    exportFileName : $exportFileName"

            $logFile = Get-WmiObject Win32_NTEventlogFile | Where-Object {$_.logfilename -eq $logFileName} 
            $status = $logFile.backupeventlog($EvtLogSavTmpPath + $exportFileName)

            if(($Debug -eq 0) -and ($DeleteEventLogs -eq 1)){
                $status = $logFile.ClearEventLog()
            }
        }
        else{
            ###prn ">>>>> No archiving required for $l.log <<<<<" 
        }

    }
    
    Border "Event logs after archiving"
    $list = GetEvents 
    prn $list
   
}

function Test-FileIdle {
    param([Parameter(Mandatory)] [string] $Path)

    try {
        $fs = [System.IO.File]::Open(
            $Path,
            [System.IO.FileMode]::Open,
            [System.IO.FileAccess]::ReadWrite,
            [System.IO.FileShare]::None
        )
        $fs.Close()
        return $true
    } catch {
        return $false
    }
}

function ZipAll(){

    Border "Archive Files" 


    foreach($b in $BackupFolders){
        
        prn "Backing up $b"

        $c=$b.tolower().replace("c:\","").replace("\","_")

        $target_folder = "$ArchiveFolder_Tmp"+"DKMS_Logs\$c\"

        New-Item -ItemType Directory -Force -Path $target_folder  | Out-Null
##123






        #move files to DKMS_Logs
        # Skip if folder doesn't exist (prevents Get-ChildItem path not found)
if (-not (Test-Path -LiteralPath $b)) {
    prn "SKIP (missing folder): $b"
    continue
}

Get-ChildItem -LiteralPath $b -File -Force -ErrorAction SilentlyContinue |
    Sort-Object LastWriteTime |
    ForEach-Object {

        $file = $_.FullName

        # Skip locked/in-use files (prevents Move-Item IO exception)
        if (-not (Test-FileIdle -Path $file)) {
            prn "SKIP (in use): $file"
            return
        }

        try {
            if ($Debug) {
                Copy-Item -LiteralPath $file -Destination $target_folder -Force -ErrorAction Stop
            } else {
                Move-Item -LiteralPath $file -Destination $target_folder -Force -ErrorAction Stop
            }
        }
        catch {
            # Race condition: file became locked after the idle check
            prn "SKIP (move failed): $file | $($_.Exception.Message)"
        }
    }
        #zip the moved files
        <#
        #return;
        goto x
        #
        try{
            
            $zipfile= "$ArchiveFolder_Tmp$c.zip"
            prn "creating zip fie $zipfile"
            $zip = [System.IO.Compression.ZipFile]::Open($zipfile, 'create')
            ##[System.IO.Compression.ZipFile]::CreateFromDirectory($b, $zipfile)
            $zip.Dispose()

            #prn "oopening zip file from archiving"
            #$compressionLevel = [System.IO.Compression.CompressionLevel]::Fastest
            #$zip = [System.IO.Compression.ZipFile]::Open($zipfile, 'update')
            
            
            #Compress-Archive -Path $b -DestinationPath "$ArchiveFolder_Tmp$c.zip" -Force
            ##Remove-Item $b"\*" -Recurse #-Force

            prn "adding fils..."

            Get-ChildItem –Path $b |
            Sort-Object LastWriteTime  |
            Foreach-Object {
                try{
                    $file = $_.FullName

                    write-output "adding  $file to $zipfile"
                    #[System.IO.Compression.ZipFileExtensions]::CreateEntryFromFile($zip, $file, (Split-Path $file -Leaf), $compressionLevel) | out-null 
                    
                    #[System.IO.Compression.ZipFileExtensions]::CreateEntryFromFile($zip, $file, $file, $compressionLevel) | out-null 
                    
                    [System.IO.Compression.ZipFileExtensions]::CreateEntryFromFile($zip, $file, $file) | out-null

                    write-out "remove $file"
                    Remove-Item $file -force
                }catch{
                    prn "error in $file"
                }
            }

            $zip.Dispose()
        }
        catch{
            $s = "$ArchiveFolder_Tmp"+"_ERROR_DIR_NOT_FOUND_"+"$c"
            prn "$b    $ArchiveFolder_Tmp$c.zip    $s"
            New-Item $s  | Out-Null
        }
        :x
        #>
    }

    #prn "Zipping archive"
    #Compress-Archive -Path $ArchiveFolder_Tmp -DestinationPath $ZipTarget -Force  
     
    # $OutFile is zipped above
    # now we add extra line in $OutFile below.  so we have 2 slightly diff version.

    prn "Report Completed on : $(get-date -f 'dddd yyyy/MM/dd HH:mm:ss')"  
    #Copy-Item -Path $OutFile -Destination $ArchiveFolder_Final | Out-Null
    #Copy-Item -Path $ReportFile -Destination $ArchiveFolder_Final | Out-Null
    
    # remove temp work files
    #Remove-Item $ArchiveFolder_Tmp  -Recurse

}

Function GetNetworkInfo(){
  Border "Network configuration"
  $Networks = Get-WmiObject win32_networkadapterconfiguration | ? {$_.IPEnabled}

  foreach($net in $Networks){
    #prn $net
    prn "DHCPEnabled      : $($net.DHCPEnabled)"
    prn "IPAddress        : $($net.IPAddress -join ',')"
    prn "Subnet Mask      : $($net.ipsubnet[0])"
    prn "DNS Servers      : $($net.DNSSearchOrder -join ',')"
    prn "Gateway          : $($net.DefaultIPgateway -join ',')"
    prn ""
  }
}

Function GenHTMLReport(){
  
  Add-Content $ReportFile "<html><body>"

  # ================== images
  Get-ChildItem $ArchiveFolder_Tmp -Filter *.jpg |
  ForEach{
    write-output $_.FullName
    $reader=[system.io.file]::openread($_.FullName)
    $sz=9000 # multiple of 3K
    $buf=new-object byte[] $sz
    $bytesRead=0

    Add-Content $ReportFile "<img width='800' alt='$_' src='data:image/jpg;base64,"
    do{
      $bytesRead=$reader.Read($buf,0,$sz);
      Add-Content $ReportFile ([convert]::ToBase64String($buf,0,$bytesRead))
    }
    while ($bytesRead -eq $sz)
    Add-Content $ReportFile "'>"
  }

  # ================== report data
  Add-Content $ReportFile "<pre>$ReportSummary</pre>"

  # ================== close html
  Add-Content $ReportFile "</body></html>"
}


Function DisableTaskSchedular($flag)
{
	if((test-Path 'C:\SBCRemediation') -and $flag){
		Write-Host disabling task schedular:$flag
		Get-ScheduledTask -TaskPath "\" -TaskName "DKMSRemediation_MonitorSBCWeb" | Stop-ScheduledTask | Disable-ScheduledTask
	} 
	elseif ((test-Path 'C:\SBCRemediation') -and  !$flag){
		Write-Host enabling task schedular:$flag
		Get-ScheduledTask -TaskPath "\" -TaskName "DKMSRemediation_MonitorSBCWeb" | Enable-ScheduledTask
	}
   
}

function CheckDKMSorSBCWinServiceStartTime {

    if (Test-Path 'C:\SBCRemediation') {
        $servicename = 'DKMS.SBC.WebApp'
        $restart_history_outfilepath = 'C:\SBCRemediation\log\SBCrestartHistory.txt'
    }
    elseif (Test-Path 'C:\DKMSRemediation') {
        $servicename = 'DKMS.Kiosk.WebApp'
        $restart_history_outfilepath = 'C:\DKMSRemediation\log\KioskrestartHistory.txt'
    }
    else {
        prn "SKIP restart history: not SBCRemediation and not DKMSRemediation"
        return
    }

    # Ensure folder exists (prevents Out-File path error)
    $outDir = Split-Path -Parent $restart_history_outfilepath
    if (-not (Test-Path $outDir)) {
        New-Item -ItemType Directory -Path $outDir -Force | Out-Null
    }

    try {
        # Pull events, but don't scream if no matches
        $events = Get-EventLog -LogName System -Source "Service Control Manager" -After (Get-Date).AddDays(-30) -ErrorAction SilentlyContinue |
                  Where-Object { $_.Message -match [regex]::Escape($servicename) } |
                  Sort-Object TimeGenerated

        if (-not $events -or $events.Count -eq 0) {
            prn "INFO: No Service Control Manager events found for $servicename in last 30 days."
            # still create the file so script doesn't fail
            "No events found for $servicename in last 10 days. $(Get-Date)" |
                Out-File -FilePath $restart_history_outfilepath -Encoding utf8 -Force
            return
        }

        $events |
            Select-Object TimeGenerated, EntryType, Source, Message |
            Format-Table -AutoSize -Wrap |
            Out-File -FilePath $restart_history_outfilepath -Encoding utf8 -Force

        prn "Saved restart history to: $restart_history_outfilepath"
    }
    catch {
        prn "SKIP restart history (error): $($_.Exception.Message)"
    }
}

#script will run once a month for backup DKMS Kiosk application
#backup Kiosk and TMS config

function BackupConfig {


#Target backup config
$dkmsctfile = "C:\DKMSClient\kiosk.ini", "C:\DKMSClient\AppSettings.config", "C:\DKMSClient\Site-Configs.xml", "C:\DKMSClient\DKMSKiosk.exe.config"
$dkmsRfile = "C:\DKMSRemediation\appsettings.json", "C:\DKMSRemediation\kiosk.ini"
$sbcRfile = "C:\SBCRemediation\appsettings.json", "C:\SBCRemediation\Config.xml"
$tmsfile = "C:\DKMSRemediationTMS\appsettings.json", "C:\DKMSRemediationTMS\kiosk.ini"

$currentDateTime = Get-Date
$formattedDateTime = $currentDateTime.ToString("yyyyMMdd")
$kiosk = "$env:COMPUTERNAME-$formattedDateTime" 


#CT PC's only
if (Test-Path 'C:\DKMSClient') {
    New-Item -Path "C:\_Maintenance\BackupConfig\$kiosk" -ItemType Directory -Force | Out-Null

    Compress-Archive -Path $dkmsctfile -DestinationPath "C:\_Maintenance\BackupConfig\$kiosk\Clientbackup.zip" -Force
    Write-Output "DKMSClient config backup successfully!"
}
# NEW CLIENT Current PCs's -MB-PPT-TUAS
elseif (Test-Path 'C:\DKMSRemediation') {
    New-Item -Path "C:\_Maintenance\BackupConfig\$kiosk" -ItemType Directory -Force | Out-Null

    Compress-Archive -Path $dkmsRfile -DestinationPath "C:\_Maintenance\BackupConfig\$kiosk\Clientbackup.zip" -Force
    Write-Output "DKMSRemediation config backup successfully!"

    if (Test-Path 'C:\DKMSRemediationTMS') {
        Compress-Archive -Path $tmsfile -DestinationPath "C:\_Maintenance\BackupConfig\$kiosk\TMSbackup.zip" -Force
        Write-Output "DKMSRemediation TMS config backup done!"
    }
}  
#SBCREMEIDATIONS PC'S
else {
    New-Item -Path "C:\_Maintenance\BackupConfig\$kiosk" -ItemType Directory -Force | Out-Null

    Compress-Archive -Path $sbcRfile -DestinationPath "C:\_Maintenance\BackupConfig\$kiosk\SBCbackup.zip" -Force
    Write-Output "SBCRemediation config backup successfully!"
}


}
	
Function HouseKeep {
	
$BasePath = "C:\"
$Prefix   = "ArchivedLogs_"
$Cutoff   = (Get-Date).AddMonths(-5)

# 1) Find folders that match the rule
$Targets = Get-ChildItem -Path $BasePath -Directory |
    Where-Object { $_.Name -like "$Prefix*" -and $_.LastWriteTime -lt $Cutoff } |
    Sort-Object LastWriteTime

# 2) Write out what is selected
"Cutoff: $Cutoff"
"Selected folders to delete: $($Targets.Count)"
$Targets | Select-Object FullName, LastWriteTime | Format-Table -AutoSize

# 3) (Optional) Delete - keep as -WhatIf for safety
$Targets | Remove-Item -Recurse -Force

}

function Invoke-DiskCleanup {
    param(
        [switch]$ClearRecycleBin,
        [switch]$ClearTemp,
        [switch]$ClearWindowsTemp,
        [switch]$ClearUpdateCache,
        [switch]$RunCleanMgr
    )

    Write-Output "[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] Cleanup started..."

    # 1) Clear Recycle Bin (all drives)
    if ($ClearRecycleBin) {
        try {
            Clear-RecycleBin -Force -ErrorAction Stop
            Write-Output "Recycle Bin cleared."
        } catch {
            Write-Output "Recycle Bin clear FAILED: $($_.Exception.Message)"
        }
    }

    # 2) Clear user temp
    if ($ClearTemp) {
        $userTemp = $env:TEMP
        try {
            Get-ChildItem -Path $userTemp -Force -ErrorAction SilentlyContinue |
                Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
            Write-Output "User temp cleared: $userTemp"
        } catch {
            Write-Output "User temp clear FAILED: $($_.Exception.Message)"
        }
    }

    # 3) Clear Windows temp (needs admin)
    if ($ClearWindowsTemp) {
        $winTemp = "C:\Windows\Temp"
        try {
            Get-ChildItem -Path $winTemp -Force -ErrorAction SilentlyContinue |
                Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
            Write-Output "Windows temp cleared: $winTemp"
        } catch {
            Write-Output "Windows temp clear FAILED: $($_.Exception.Message)"
        }
    }

    # 4) Clear Windows Update download cache (needs admin)
    if ($ClearUpdateCache) {
        try {
            Stop-Service wuauserv -Force -ErrorAction SilentlyContinue
            Stop-Service bits -Force -ErrorAction SilentlyContinue

            Remove-Item "C:\Windows\SoftwareDistribution\Download\*" -Force -Recurse -ErrorAction SilentlyContinue
            Write-Output "Windows Update cache cleared."

            Start-Service bits -ErrorAction SilentlyContinue
            Start-Service wuauserv -ErrorAction SilentlyContinue
        } catch {
            Write-Output "Update cache clear FAILED: $($_.Exception.Message)"
        }
    }

    # 5) Optional: run built-in Disk Cleanup (cleanmgr)
    # Note: cleanmgr is older and not always present on newer builds.
    if ($RunCleanMgr) {
        try {
            Start-Process -FilePath "cleanmgr.exe" -ArgumentList "/verylowdisk" -Wait -ErrorAction Stop
            Write-Output "cleanmgr.exe finished."
        } catch {
            Write-Output "cleanmgr.exe failed/not available: $($_.Exception.Message)"
        }
    }

    Write-Output "[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] Cleanup completed."
}








	

Function DoAll(){

	
    # create folder first in order to log
    New-Item -ItemType Directory -Force -Path $ArchiveFolder_Tmp  | Out-Null
	Start-Transcript -Path "$ArchiveFolder_Tmp\$ArchiveName.log" -Append
    
        
    prn "Maintenance Script Version : 2026-02-11"
    prn "Report Timestamp : $(get-date -f 'dddd yyyy/MM/dd HH:mm:ss')"
    
    

    GetFileInfo
    CheckDKMSorSBCWinServiceStartTime
    GetAvailResources
    GetProcCpuRam

    GetNetworkInfo
    GetPorts
    
    BackupEventLog

    GenHTMLReport
	
	
    DisableTaskSchedular($true)
    ZipAll
	DisableTaskSchedular($false)
    BackupConfig
	HouseKeep
	Invoke-DiskCleanup -ClearRecycleBin -ClearTemp
	Stop-Transcript
    
}

DoAll
